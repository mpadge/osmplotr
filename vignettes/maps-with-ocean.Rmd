---
title: "Rendering Ocean"
author: "Richard Beare"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        #number_sections: true
        theme: flatly
vignette: >
  %\VignetteIndexEntry{Maps with Ocean}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# 1 Introduction

It may often be desirable to separately colour two or more portions of a map
that are separated by a line object. This is not directly possible because only
polygons can be filled with colour, not lines.  The classic example where this arises is with coastlines. These
are always represented in OpenStreetMap as line objects, preventing any ability
to simply colour land and ocean separately. Converting these osm objects to
polygons for plotting turns out to be a really tough problem. The original
attempt using `osm_line2poly()` tends to break if the bounding box interacts
with the coastline in complex ways. This is a second attempt built entirely
around operations in the `sf` package, which implements many of the complex
geometery operations required.

For testing only at this stage. No attempt to make this vignette friendly for
continuous integration etc. Also importing too many other packages - sf and purrr - to make this work
fit nicely with osmplotr.

I'm also using the development version of `ggplot2`, which implements `geom_sf`

# Tricky case A
```{r, echo=FALSE}
library(osmplotr)
library(osmdata)
library(sf)
library(ggplot2)

getCoast <- function(bbox)
  {
    qry <- opq(bbox)
    qry <- add_osm_feature(qry, key = "natural", value = "coastline")
    res <- osmdata_sf(qry)
    res$bbox <- bbox
    return(res)
  }
  
```

```{r, cache=TRUE, warning=FALSE, message=FALSE}
bbox.F <- rbind(c(min= 144.75, max = 145.6),
                c(min= -38.41, max = -37.75))
rownames(bbox.F) <- c("x", "y")

osm.F <- getCoast(bbox.F)

land <- sf_land(osm.F, bbox.F)
```
Why is this one tricky? See below : we have a mix of coastline represented as polygons (red) and lines (blue).
There is an island made of multiple lines that is cut by the bounding box. There are also small sections of
land cut by the bounding box. Finally, the peninsula cut by the bounding box is not complete connected
outside the bounding box (i.e) the query hasn't returned "ways" that are connected.

```{r, echo=FALSE}
  bbxcoords <- rbind(c(bbox.F[1, 2], bbox.F[2, 2]),
                     c(bbox.F[1, 2], bbox.F[2, 1]),
                     c(bbox.F[1, 1], bbox.F[2, 1]),
                     c(bbox.F[1, 1], bbox.F[2, 2])
  )
  bbxcoords <- rbind(bbxcoords, bbxcoords[1,])
  bbx <- st_sf(st_sfc(st_cast(st_multipoint(bbxcoords), "POLYGON"), crs=st_crs(osm.F$osm_lines)))
  ggplot() + geom_sf(data=bbx, fill=NA) + 
    geom_sf(data=osm.F$osm_lines, colour='blue') + 
    geom_sf(data=osm.F$osm_polygons, colour='red')
```

The strategy implemented in `sf_land` is:

1. Union of `ways`
1. Polygonize to isolate islands.
1. Clip non polygons with the bounding box.
1. Union of bounding box border each clipped line.
1. Polygonize.
1. Identify parts of the resulting polygons that are not from the bounding box (i.e original ways)
1. Check whether the direction or points in those sections has changed. SF always creates clockwise polygons while OSM ways have land on the left, so those polygons with way points in a reversed direction are land.
1. Pairwise, non empty, intersections between land polygons until there are no intersecting pairs.

```{r, echo=FALSE}

check_bbox_arg <- function (bbox)
{
  if (missing (bbox))
    stop ('bbox must be provided')
  if (is (bbox, 'sf')) # sf obj submitted to osm_basemap
  {
    if (is (bbox$geometry, "sfc_LINESTRING") |
        is (bbox$geometry, "sfc_POINT"))
      xy <- do.call (rbind, bbox$geometry)
    else if (is (bbox$geometry, "sfc_POLYGON"))
      xy <- do.call (rbind, lapply (bbox$geometry, function (i) i [[1]]))
    else if (is (bbox$geometry, "sfc_MULTIPOLYGON") |
             is (bbox$geometry, "sfc_MULTILINESTRING"))
      xy <- do.call (rbind, lapply (bbox$geometry,
                                    function (i) i [[1]] [[1]]))
    bbox <- t (apply (xy, 2, range))
    rownames (bbox) <- c ("x", "y")
    colnames (bbox) <- c ("min", "max")
  }
  if (!is.numeric (bbox))
    stop ('bbox is not numeric')
  if (length (bbox) < 4)
    stop ('bbox must have length = 4')
  if (length (bbox) > 4)
  {
    warning ('bbox has length > 4; only first 4 elements will be used')
    bbox <- matrix (bbox [1:4], 2, 2)
  }

  return (bbox)
}

osm_basemap2 <- function (bbox, structures, bg = 'gray20')
{
  # ---------------  sanity checks and warnings  ---------------
  bbox <- check_bbox_arg (bbox)
  if (!missing (structures))
  {
    check_structures_arg (structures)
    bg <- structure$cols [which (structures$structure == 'background')]
  }
  #check_col_arg (bg)
  if (length (bg) > 1)
  {
    warning ('bg has length > 1; only first element will be used')
    bg <- bg [1]
  }
  # ---------------  end sanity checks and warnings  ---------------

  map_theme <- set_map_theme2 (bg = bg)

  lon <- lat <- NA
  map <- ggplot2::ggplot () + map_theme +
    ## xlim stuff appears to need to be added with coord_sf at the end
    ## This causes warnings from the sf geom.
    #ggplot2::coord_map (xlim = range (bbox[1, ]),
    #                    ylim = range (bbox[2, ])) +
    ## don't need this as the sf geom deals with it.
    #ggplot2::aes(x = lon, y = lat) +
    ggplot2::scale_x_continuous (expand = c(0, 0)) +
    ggplot2::scale_y_continuous (expand = c(0, 0))

  return (map)
}

set_map_theme2 <- function (bg)
{
  theme <- ggplot2::theme_minimal ()
  theme$panel.background <- ggplot2::element_rect (fill = bg, size = 0)
  theme$line <- ggplot2::element_blank ()
  theme$axis.text <- ggplot2::element_blank ()
  theme$axis.title <- ggplot2::element_blank ()
  theme$plot.margin <- ggplot2::margin (rep (ggplot2::unit (0, 'null'), 4))
  theme$plot.margin <- ggplot2::margin (rep (ggplot2::unit (1, 'line'), 4))
  #theme$legend.position <- 'none'
  theme$axis.ticks.length <- ggplot2::unit (0, 'null')

  return (theme)
}

```

```{r}
  lon.map2 <- osm_basemap2(bbox = bbox.F,
                           bg = 'slategrey')
  coast <- rbind(osm.F$osm_lines, osm.F$osm_polygons)
  lon.map2 <- lon.map2 +
    geom_sf(data=st_sf(land), fill='green', colour=NA) +
    geom_sf(data=coast, colour='red', fill=NA, size=0.2) 
  lon.map2 + guides(size=FALSE) +
    coord_sf(xlim=range(bbox.F[1, ]), ylim=range(bbox.F[2, ])) +
    theme(panel.grid.major = element_line(colour = 'transparent'), panel.border = element_rect( fill = NA))
```

# A related area
This map is the one that lead me to discover problems with the first attempt in this PR. A slightly different BB around Frankston.

```{r, message=FALSE}
#library(ggmap)
#frankston <- get_map("Frankston, Victoria, Australia", zoom=10)
#bb <- attr(frankston, "bb")
## Change this to fit our data
#bbox.Fgg <- rbind(c(min= bb$ll.lon, max = bb$ur.lon),
#                  c(min= bb$ll.lat, max = bb$ur.lat))

bbox.Fgg <-rbind(c(min= 144.69623, max = 145.57514),
                c(min= -38.50326, max = -37.81218))
rownames(bbox.Fgg) <- c("x", "y")
osm.Fgg <- getCoast(bbox.Fgg)
land.fgg <- sf_land(osm.Fgg, bbox.Fgg)
lon.fgg <- osm_basemap2(bbox = bbox.Fgg,
                         bg = 'slategrey')
coast.Fgg <- rbind(osm.Fgg$osm_lines, osm.Fgg$osm_polygons)

lon.fgg <- lon.fgg +
  geom_sf(data=st_sf(land.fgg), fill='green', colour=NA) +
  geom_sf(data=coast.Fgg, colour='red', fill=NA, size=0.2) 
lon.fgg + guides(size=FALSE) +
  coord_sf(xlim=range(bbox.Fgg[1, ]), ylim=range(bbox.Fgg[2, ])) +
  theme(panel.grid.major = element_line(colour = 'transparent'), panel.border = element_rect( fill = NA))


```


# Test cases from old attempt

Fetch the test data. A variable name with `WE` indicates that the coast enters the bounding box
on the western side and exits on the east. The land is on the left when following that path.
```{r, cache=TRUE}
    bbWE <- get_bbox (c(142.116906, -38.352713, 142.205162, -38.409661))
    coastWE <- getCoast(bbWE)

    bbEW <- get_bbox(c(144.603127, -38.104003, 144.685557, -38.135596))
    coastEW <- getCoast(bbEW)

    bbNS <- get_bbox(c(143.807998, -39.770986, 143.906494, -39.918643))
    coastNS <- getCoast(bbNS)

    bbSN <- get_bbox(c(144.073544, -39.854586, 144.149318, -39.960047))
    coastSN <- getCoast(bbSN)

    bbWW <- get_bbox(c(144.904865, -37.858295, 144.923679, -37.874367))
    coastWW <- getCoast(bbWW)

    bbEE <- get_bbox(c(144.643383, -38.294671, 144.692197, -38.336022))
    coastEE <- getCoast(bbEE)

    bbNN <- get_bbox(c(145.856321, -38.831642, 146.050920, -38.914031))
    coastNN <- getCoast(bbNN)

    bbSS <- get_bbox(c(146.363768, -38.770345, 146.486389, -38.837287))
    coastSS <- getCoast(bbSS)

    bbEN <- get_bbox(c(144.738212, -38.337690, 144.758053, -38.346966))
    coastEN <- getCoast(bbEN)

    bbEWWS <- get_bbox(c(144.693077, -38.307526, 144.729113, -38.343997 ))
    coastEWWS <- getCoast(bbEWWS)

    bbWS <- get_bbox(c(143.164906 ,-38.704885, 143.2075563, -38.7462058 ))
    coastWS <- getCoast(bbWS)

```
```{r, echo=FALSE}
oneGGmap <- function(osd){
  ochRe_sea <- osmplotr::adjust_colours('slategrey', 0.5)
  ochRe_land <- osmplotr::adjust_colours("green", 0.5)
  ochRe_coast <- 'red'

  land <- st_sf(sf_land(osd, osd$bbox))
  lon.map2 <- osm_basemap2(bbox = osd$bbox,
                           bg = ochRe_sea)
  coast <- rbind(osd$osm_lines, osd$osm_polygons)
  lon.map2 <- lon.map2 +
    geom_sf(data=land, fill=ochRe_land, colour=NA) +
    geom_sf(data=coast, colour=ochRe_coast, fill=NA, size=0.2)
  lon.map2 <- lon.map2 + 
    guides(size=FALSE)
  lon.map2 + coord_sf(xlim=range(osd$bbox[1, ]), ylim=range (osd$bbox[2, ])) +
    theme(panel.grid.major = element_line(colour = 'transparent'), panel.border = element_rect( fill = NA))

}

```

```{r, warning=FALSE, message=FALSE}
oneGGmap(coastWE)
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastEW)
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastNS)
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastSN)
```

```{r, warning=FALSE, message=FALSE}
oneGGmap(coastWW)
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastEE)
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastNN)
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastSS)
```

```{r, warning=FALSE, message=FALSE}
oneGGmap(coastEN)
```
     
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastEWWS)
```
     
```{r, warning=FALSE, message=FALSE}
oneGGmap(coastWS)
```
     
## Only an island, but not already a polygon
```{r}
bbox.king <- rbind(c(min= 143.716560, max = 144.245415),
                c(min= -40.198267, max = -39.526277))
rownames(bbox.king) <- c("x", "y")

osm.k <- getCoast(bbox.king)

```

Strangely huge number of polygons - someone must have mapped every little rock!
```{r}
ggplot() + geom_sf(data=osm.k$osm_lines, colour='red') + geom_sf(data=osm.k$osm_polygons, colour='blue')
```
```{r, warning=FALSE, message=FALSE}
oneGGmap(osm.k)
```


     